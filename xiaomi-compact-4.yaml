esphome:
  on_boot: 
    priority: 600  # Run before most components initialize
    then:
      - output.turn_on: motorPwmOutput
      - output.set_level:
          id: motorPwmOutput
          level: 50%
      - switch.turn_off: motorEn  # Motor OFF during startup
      - lambda: "id(devEnabled).publish_state(false);"
      - delay: 2s  # Wait for system to stabilize
      - script.execute: playStartupSound

esp32:
  variant: ESP32
  board: esp32dev
  flash_size: 4MB
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_FREERTOS_UNICORE: y
    advanced:
      ignore_efuse_mac_crc: true
      ignore_efuse_custom_mac: true

wifi:
  id: wifiClient
  on_connect: 
    - lambda: "id(wifiConnected).publish_state(true);"
  on_disconnect: 
    - lambda: "id(wifiConnected).publish_state(false);"
          
web_server:
  include_internal: true

# UART for PM2.5 sensor
uart:
  - id: pm25uart
    tx_pin: GPIO17
    rx_pin: GPIO16
    baud_rate: 9600 

# I2C for LED control
i2c:
  sda: GPIO14
  scl: GPIO27
  id: i2cLeds
  scan: false

# I2C device addresses for HID controls
i2c_device:
  - id: cmdHidBrightness
    address: 0x24 
  - id: cmdHidStatusLeds
    address: 0x34
  - id: cmdHidBacklightOnOffButton
    address: 0x35
  - id: cmdHidBacklightBrightnessChangeButton
    address: 0x36
  - id: cmdHidBacklightModeChangeButton
    address: 0x37

# Constants (defined in substitutions for reusability)
substitutions:
  button_led_on: "0x3C"
  button_led_off: "0x00"
  filter_lifetime_hours: "2160"  # 90 days * 24 hours

switch:
  # HID Button LEDs
  - platform: template
    name: "HID Backlight - On/Off Button"
    id: hidBacklightOnOffButton
    internal: true
    optimistic: true
    on_state: 
      - lambda: |-
          auto val = x ? ${button_led_on} : ${button_led_off};
          id(cmdHidBacklightOnOffButton).write_bytes(val, 0, 0);

  - platform: template
    name: "HID Backlight - Brightness Change Button"
    id: hidBacklightBrightnessChangeButton
    internal: true
    optimistic: true
    on_state: 
      - lambda: |-
          auto val = x ? ${button_led_on} : ${button_led_off};
          id(cmdHidBacklightBrightnessChangeButton).write_bytes(val, 0, 0);

  - platform: template
    name: "HID Backlight - Change Mode Button"
    id: hidBacklightModeChangeButton
    internal: true
    optimistic: true
    on_state: 
      - lambda: |-
          auto val = x ? ${button_led_on} : ${button_led_off};
          id(cmdHidBacklightModeChangeButton).write_bytes(val, 0, 0);

  # Device controls
  - platform: template
    name: "Child Lock"
    id: childLock
    optimistic: true
    restore_value: true
    icon: mdi:lock
    on_state: 
      - script.execute: hidUpdate
      - if:
          condition:
            lambda: "return x;"
          then:
            - script.execute: playLockSound
          else:
            - script.execute: playUnlockSound

  - platform: template
    id: replaceFilter
    name: "Replace Filter"
    optimistic: true
    restore_value: true
    icon: mdi:filter-off
    on_state: 
      - script.execute: hidUpdate
      - if:
          condition:
            lambda: "return x;"
          then:
            - script.execute: playWarningSound

  - platform: gpio
    pin: GPIO2
    id: motorEn
    name: "Motor Enabled"
    internal: true

  - platform: template
    name: "WiFi Enable"
    id: wifiEnable
    internal: true
    restore_mode: DISABLED
    lambda: "return !id(wifiClient).is_disabled();"
    turn_on_action:
      - wifi.enable          
    turn_off_action:
      - wifi.disable

  - platform: template
    name: "Sound Notifications"
    id: soundEnabled
    optimistic: true
    restore_value: true
    initial_state: true
    icon: mdi:volume-high

# PM2.5 sensor polling
interval:
  - interval: 30s
    then: 
      - uart.write: 
          id: pm25uart
          data: [0x11, 0x02, 0x0B, 0x01, 0xE1]     
      - delay: 100ms            
      - lambda: |-
          static std::deque<uint8_t> buf;
          const int FRAME_LEN = 20;
          const uint8_t HEADER[] = {0x16, 0x11, 0x0B};

          // Fill buffer
          uint8_t tmp;
          while (buf.size() < FRAME_LEN && id(pm25uart).read_byte(&tmp)) {
            buf.push_back(tmp);
          }

          while (true) {
            if (buf.size() < 3) break;

            // Align on header
            while (buf.size() >= 3 &&
                   !(buf[0] == HEADER[0] && buf[1] == HEADER[1] && buf[2] == HEADER[2])) {
              buf.pop_front();
            }

            if (buf.size() < 3) break;
            if ((int)buf.size() < FRAME_LEN) break;

            // Extract frame
            uint8_t frame[FRAME_LEN];
            for (int i = 0; i < FRAME_LEN; i++) {
              frame[i] = buf.front();
              buf.pop_front();
            }

            uint16_t pm25val = (((uint16_t)frame[15]) << 8) | frame[16];
            id(pm25sensor).publish_state(pm25val);            
          }

  # Filter runtime tracker - updates every hour
  - interval: 1h
    then:
      - lambda: |-
          if (id(devEnabled).state && id(motorSpeed).state > 0) {
            float current = id(filterRuntimeHours).state;
            id(filterRuntimeHours).publish_state(current + 1.0f);
            
            // Check if filter needs replacement
            if (current + 1.0f >= ${filter_lifetime_hours}) {
              id(replaceFilter).publish_state(true);
            }
          }

binary_sensor:
  # Physical buttons with child lock support
  - platform: gpio
    pin: 
      number: GPIO5
      inverted: true
    name: "HID Change Mode Button"
    internal: true
    on_click:
      - max_length: 1s
        then:
          - if: 
              condition:
                and:
                  - lambda: "return id(devEnabled).state;"
                  - lambda: "return !id(childLock).state;"
              then:
                - select.next: devMode
                - script.execute: playClickSound
              else:
                - script.execute: playBlockedSound
      - min_length: 7s
        max_length: 14s          
        then:
          - lambda: |-
              bool current = id(childLock).state;
              id(childLock).publish_state(!current);

  - platform: gpio
    pin: 
      number: GPIO18
      inverted: true
    name: "HID Light Button"
    internal: true
    on_click:
      - max_length: 1s
        then:
          - if:
              condition:
                and:
                  - lambda: "return id(devEnabled).state;"
                  - lambda: "return !id(childLock).state;"
              then:
                - select.next: brightness
                - script.execute: playClickSound
              else:
                - script.execute: playBlockedSound

  - platform: gpio
    pin: 
      number: GPIO19
      inverted: true
    name: "HID On/Off Button"
    internal: true
    on_click: 
      - max_length: 1s
        then: 
          - if:
              condition:
                lambda: "return !id(childLock).state;"
              then:
                - lambda: |-
                    auto enabled = id(devEnabled).state;
                    id(devEnabled).publish_state(!enabled);
                - if:
                    condition:
                      lambda: "return id(devEnabled).state;"
                    then:
                      - script.execute: playPowerOnSound
                    else:
                      - script.execute: playPowerOffSound
              else:
                - script.execute: playBlockedSound
            
  # Virtual sensors for HID status updates
  - platform: template
    id: hidChildLock
    name: "HID Child Lock Active"
    internal: true
    on_state: 
      - lambda: |-
          uint8_t state = id(hidComponentStatus).has_state() ? id(hidComponentStatus).state : 0x00;
          state = x ? (state | 0x04) : (state & ~0x04);
          id(hidComponentStatus).publish_state(state);

  - platform: template
    id: hidWifiConnected
    name: "HID WiFi connected"
    internal: true
    on_state: 
      - lambda: |-
          uint8_t state = id(hidComponentStatus).has_state() ? id(hidComponentStatus).state : 0x00;
          state = x ? (state | 0x02) : (state & ~0x02);
          id(hidComponentStatus).publish_state(state);

  - platform: template
    id: hidReplaceFilter
    name: "HID Replace Filter"
    internal: true
    on_state: 
      - lambda: |-
          uint8_t state = id(hidComponentStatus).has_state() ? id(hidComponentStatus).state : 0x00;
          state = x ? (state | 0x01) : (state & ~0x01);
          id(hidComponentStatus).publish_state(state);

  - platform: template
    id: wifiConnected
    name: "WiFi connected"
    internal: true
    on_state_change: 
      - script.execute: hidUpdate

  - platform: template
    id: devEnabled
    name: "Device Enabled"
    internal: true
    on_state: 
      - script.execute: hidUpdate
      - script.execute: motorUpdate

sensor:
  - platform: template
    name: "PM 2.5"
    id: pm25sensor
    device_class: pm25
    unit_of_measurement: "μg/m³"
    accuracy_decimals: 0
    on_value: 
      - script.execute: hidUpdate
      - script.execute: motorUpdate

  - platform: template
    name: "HID Component Status"
    id: hidComponentStatus
    internal: true
    accuracy_decimals: 0    
    on_value: 
      - lambda: |-
          ESP_LOGD("main", "Update LEDs: state=%02x", uint8_t(x));
          id(cmdHidStatusLeds).write_bytes(uint8_t(x), 0, 0);
  
  - platform: pulse_counter
    pin: GPIO34
    name: "Motor Actual RPM"
    unit_of_measurement: "RPM"
    icon: "mdi:fan"
    update_interval: 1s
    accuracy_decimals: 0
    filters:
      - lambda: "return x / 15.0f;"

  # Filter runtime tracking
  - platform: template
    name: "Filter Runtime Hours"
    id: filterRuntimeHours
    unit_of_measurement: "h"
    icon: mdi:clock-outline
    accuracy_decimals: 0
    state_class: total_increasing

  - platform: template
    name: "Filter Life Remaining"
    unit_of_measurement: "%"
    icon: mdi:air-filter
    accuracy_decimals: 0
    lambda: |-
      float runtime = id(filterRuntimeHours).state;
      float remaining = 100.0f * (1.0f - runtime / ${filter_lifetime_hours});
      return std::max(0.0f, remaining);
    update_interval: 1h

select:
  - platform: template
    name: "HID Mode"
    id: hidMode
    optimistic: true
    internal: true
    icon: mdi:brightness-5
    options:
      - FAV
      - NIGHT
      - AUTO
      - TURNOFF
    initial_option: TURNOFF
    on_value: 
      - lambda: |-
          const uint8_t LED_FAV = 0x20;
          const uint8_t LED_NIGHT = 0x10;
          const uint8_t LED_AUTO = 0x08;
          const uint8_t LED_MASK = LED_FAV | LED_NIGHT | LED_AUTO;
          
          uint8_t led = 0;
          if (x == "FAV") led = LED_FAV;
          else if (x == "NIGHT") led = LED_NIGHT;
          else if (x == "AUTO") led = LED_AUTO;
          
          uint8_t state = id(hidComponentStatus).has_state() ? id(hidComponentStatus).state : 0x00;
          state = (state & ~LED_MASK) | led;
          id(hidComponentStatus).publish_state(state);

  - platform: template
    name: "Mode"
    id: devMode
    optimistic: true
    icon: mdi:menu
    options:
      - FAV
      - NIGHT
      - AUTO
    initial_option: AUTO
    restore_value: true
    on_value: 
      - script.execute: hidUpdate
      - script.execute: motorUpdate

  - platform: template
    name: "Brightness"
    id: brightness
    optimistic: true
    icon: mdi:white-balance-sunny
    options:
      - FULL
      - MID
      - ZERO
    initial_option: FULL
    on_value: 
      - script.execute: hidUpdate  

output:
  - platform: ledc
    pin: GPIO4
    id: buzzer

  - platform: ledc
    pin: GPIO21
    id: RGB_Red

  - platform: ledc
    pin: GPIO32
    id: RGB_Orange

  - platform: ledc
    pin: GPIO33
    id: RGB_Green

  - platform: ledc
    pin: GPIO26
    id: motorPwmOutput
    frequency: 300Hz

light:
  - platform: monochromatic
    output: RGB_Red
    id: StatusRed

  - platform: monochromatic
    output: RGB_Orange
    id: StatusOrange

  - platform: monochromatic
    output: RGB_Green
    id: StatusGreen

number:
  - platform: template
    id: motorSetpoint
    name: "Motor Setpoint"
    min_value: 100
    max_value: 700
    step: 10
    initial_value: 300
    unit_of_measurement: "Hz"
    optimistic: true
    internal: true
    on_value:
      - output.ledc.set_frequency:
          id: motorPwmOutput
          frequency: !lambda "return x;"

  - platform: template
    id: motorSpeed
    name: "Motor Speed"
    min_value: 0
    max_value: 100
    unit_of_measurement: '%'
    icon: mdi:speedometer
    step: 1
    initial_value: 0  # Start at 0 to prevent startup spinning
    optimistic: true
    internal: true
    on_value:
      - number.set: 
          id: motorSetpoint
          value: !lambda "return x * 6 + 100;"

  - platform: template
    id: motorSpeedFav
    name: "Motor Speed Favorite Mode"
    min_value: 0
    max_value: 100
    icon: mdi:heart
    step: 1
    initial_value: 30
    restore_value: true
    optimistic: true
    on_value:
      - script.execute: motorUpdate

  - platform: template
    id: motorSpeedNight
    name: "Motor Speed at Night Mode"
    min_value: 0
    max_value: 100
    icon: mdi:weather-night
    entity_category: config
    step: 1
    initial_value: 10
    restore_value: true
    optimistic: true
    on_value:
      - script.execute: motorUpdate

  - platform: template
    id: motorSpeedP
    name: "Motor Speed P Factor"
    min_value: 0.01
    max_value: 10
    step: 0.01    
    initial_value: 3
    restore_value: true
    optimistic: true
    entity_category: config
    on_value: 
      - script.execute: motorUpdate

  - platform: template
    name: "HID Backlight Brightness"
    id: hidBacklightBrightness
    internal: true
    min_value: 1
    max_value: 8
    step: 1
    optimistic: true
    on_value: 
      - lambda: |-
          uint8_t lvl = (uint8_t) std::clamp(x, 1.0f, 8.0f);
          if (lvl == 8) lvl = 0;
          id(cmdHidBrightness).write_bytes((lvl << 4) | 0x01, 0, 0);

script:
  - id: hidUpdate
    then:
      - lambda: |-
          // Get current state
          std::string brightnessMode = id(brightness).state;
          bool isDevEnabled = id(devEnabled).state;
          bool isFullBacklight = brightnessMode == "FULL";
          bool isNoBacklight = brightnessMode == "ZERO";
          bool disableHid = isNoBacklight || !isDevEnabled;
          
          // Update backlight brightness
          uint8_t expectedBacklight = (isFullBacklight && isDevEnabled) ? 8 : 3;
          id(hidBacklightBrightness).publish_state(expectedBacklight);
          
          // Update button LEDs (child lock affects these)
          bool buttonsEnabled = !disableHid && !id(childLock).state;
          id(hidBacklightModeChangeButton).publish_state(buttonsEnabled);
          id(hidBacklightBrightnessChangeButton).publish_state(buttonsEnabled);
          id(hidBacklightOnOffButton).publish_state(true);  // Power button always active
          
          // Update mode display
          id(hidMode).make_call().set_option(disableHid ? "TURNOFF" : id(devMode).state).perform();
          
          // Update status indicators
          id(hidChildLock).publish_state(disableHid ? false : id(childLock).state);
          id(hidWifiConnected).publish_state(disableHid ? false : id(wifiConnected).state);
          id(hidReplaceFilter).publish_state(disableHid ? false : id(replaceFilter).state);

          // Update RGB status lights
          if (disableHid || !id(pm25sensor).has_state()) {
            id(StatusGreen).turn_off().perform();
            id(StatusOrange).turn_off().perform();
            id(StatusRed).turn_off().perform();
          } else {
            float brightnessCoef = isFullBacklight ? 1.0f : 0.6f;
            float green = 0, orange = 0, red = 0;
            float pm25 = id(pm25sensor).state;
            
            if (pm25 < 10) {
              green = 1.0f;
            } else if (pm25 < 20) {
              green = 0.6f;
              orange = 1.0f;
            } else if (pm25 < 30) {
              green = 0.35f;
              orange = 1.0f;
            } else if (pm25 < 40) {
              orange = 1.0f;
              red = 0.35f;
            } else {
              orange = 1.0f;
              red = 1.0f;
            }
            
            id(StatusGreen).turn_on().set_brightness(green * brightnessCoef).perform();
            id(StatusOrange).turn_on().set_brightness(orange * brightnessCoef).perform();
            id(StatusRed).turn_on().set_brightness(red * brightnessCoef).perform();
          }

  - id: motorUpdate
    then:
      - if:
          condition:
            lambda: "return id(devEnabled).state;"
          then:
            - lambda: |-
                auto mode = id(devMode).state;
                float speed;
                
                if (mode == "AUTO") {
                  if (id(pm25sensor).has_state()) {
                    speed = id(pm25sensor).state * id(motorSpeedP).state;
                  } else {
                    speed = id(motorSpeedFav).state;
                  }
                } else if (mode == "FAV") {
                  speed = id(motorSpeedFav).state;
                } else {  // NIGHT
                  speed = id(motorSpeedNight).state;
                }
                
                id(motorSpeed).publish_state(std::clamp(speed, 0.0f, 100.0f));
            - switch.turn_on: motorEn
          else:
            - number.set:
                id: motorSpeed
                value: 0
            - switch.turn_off: motorEn

  # Sound notification scripts
  - id: playClickSound
    mode: restart
    then:
      - if:
          condition:
            lambda: "return id(soundEnabled).state;"
          then:
            - rtttl.play: "click:d=4,o=5,b=100:16c6"

  - id: playBlockedSound
    mode: restart
    then:
      - if:
          condition:
            lambda: "return id(soundEnabled).state;"
          then:
            - rtttl.play: "blocked:d=4,o=5,b=200:8e,8e"

  - id: playLockSound
    mode: restart
    then:
      - if:
          condition:
            lambda: "return id(soundEnabled).state;"
          then:
            - rtttl.play: "lock:d=4,o=5,b=200:8c,8e,8g"

  - id: playUnlockSound
    mode: restart
    then:
      - if:
          condition:
            lambda: "return id(soundEnabled).state;"
          then:
            - rtttl.play: "unlock:d=4,o=5,b=200:8g,8e,8c"

  - id: playPowerOnSound
    mode: restart
    then:
      - if:
          condition:
            lambda: "return id(soundEnabled).state;"
          then:
            - rtttl.play: "poweron:d=4,o=5,b=180:8c,8e,8g,8c6"

  - id: playPowerOffSound
    mode: restart
    then:
      - if:
          condition:
            lambda: "return id(soundEnabled).state;"
          then:
            - rtttl.play: "poweroff:d=4,o=5,b=180:8c6,8g,8e,8c"

  - id: playWarningSound
    mode: restart
    then:
      - if:
          condition:
            lambda: "return id(soundEnabled).state;"
          then:
            - rtttl.play: "warning:d=4,o=5,b=200:8e,8p,8e,8p,8e"

  - id: playStartupSound
    mode: restart
    then:
      - if:
          condition:
            lambda: "return id(soundEnabled).state;"
          then:
            - rtttl.play: "startup:d=4,o=5,b=160:8c,8d,8e,8f,8g"

rtttl:
  output: buzzer
  id: sound
  gain: 0.8

button:
  - platform: restart
    name: "Restart"

  - platform: template
    name: "On/Off Button"
    icon: mdi:power
    on_press:
      - if:
          condition:
            lambda: "return !id(childLock).state;"
          then:
            - lambda: |-
                auto enabled = id(devEnabled).state;
                id(devEnabled).publish_state(!enabled);
            - if:
                condition:
                  lambda: "return id(devEnabled).state;"
                then:
                  - script.execute: playPowerOnSound
                else:
                  - script.execute: playPowerOffSound
          else:
            - script.execute: playBlockedSound

  - platform: template
    name: "Reset Filter Runtime"
    icon: mdi:filter-remove
    on_press:
      - lambda: |-
          id(filterRuntimeHours).publish_state(0);
          id(replaceFilter).publish_state(false);
      - script.execute: playClickSound
